// 给定一个 排序数组，需要原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度 -- <1>
// 不得使用额外的数组空间，必须在原地修改输入数组并在使用O(1)额外空间的条件下完成 -- <2>
// 示例： 给定 nums = [1,1,2]
// 函数应该返回新的长度 2 && 原数组 nums 的前两个元素被修改为 1，2 即 nums = [1.2,2]--<3>
// 不需要考虑数组中超出新长度后面的元素 --<4>
// 摘抄题目解释内部操作 根据返回函数的长度len，会打印出该长度范围内的元素 --<5>

// 分析：
// 参数为 排序数组
// 由<1><2><3> 可知 要求的函数是对原数组中的元素进行修改 是虚拟替换重复元素从而达到删除的效果
// 由<2><4><5> 可知 返回结果为实际数组新长度的必要意义

// 1、函数调用之后 原数组长度不变
// 2、不能新建一个数组存储删除重复数据后的数组，因为空间复杂度要求为 O(1)
// 3、根据修改替换原数组重复元素 和 返回长度 动态遍历出 不准新建的新数组里应该有的元素

/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function (nums) {
    if (nums == null || nums.length == 0) return 0;
    var front = 0;
    var back = 1;
    while (back < nums.length) {
        if (nums[front] != nums[back]) {
            front++;
            nums[front] = nums[back];
        }
        back++;
    }
    return front + 1;

    // **********
    // if (nums.length == 0) return 0;
    // var i = 0;
    // for (var j = 1; j < nums.length; j++) {
    //     if (nums[j] != nums[i]) {
    //         i++;
    //         nums[i] = nums[j];
    //     }
    // }
    // return i + 1;
};

// 双指针法
// 首先注意数组是有序的，那么重复的元素一定会相邻。
// 要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。
// 考虑用 2 个指针，一个在前记作 p，一个在后记作 q
// 算法流程如下：
//      1、比较 p 和 q 位置的元素是否相等。
//      如果相等，q 后移 1 位
//      如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位
//      重复上述过程，直到 q 等于数组长度。
//      2、返回 p + 1，即为新数组长度。
// 时间复杂度：O(n)
// 空间复杂度：O(1)
